# Copyright 2025 The EasyDeL Author @erfanzar (Erfan Zare Chavoshi).
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#     https://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Utility functions for tool call parsing in EasyDeL inference.

This module provides essential helper functions for parsing and processing
tool calls from Large Language Model outputs. It includes utilities for:

- Partial JSON parsing and validation
- String manipulation for streaming token differences
- Common prefix/suffix extraction for incremental parsing
- Whitespace handling in structured outputs

These utilities are fundamental to the streaming tool call extraction
process, enabling parsers to handle incomplete JSON/XML structures
as they are being generated token-by-token.

Key Functions:
    find_common_prefix: Find shared prefix between strings.
    find_common_suffix: Find shared suffix between strings.
    extract_intermediate_diff: Extract new content for streaming.
    partial_json_loads: Parse potentially incomplete JSON.
    is_complete_json: Validate JSON completeness.
    find_all_indices: Locate all occurrences of a substring.
    consume_space: Skip whitespace characters in a string.

Example:
    >>> from easydel.inference.tools.utils import partial_json_loads
    >>> from partial_json_parser.core.options import Allow
    >>> obj, consumed = partial_json_loads('{"name": "test"', Allow.ALL)
    >>> print(obj)
    {'name': 'test'}
"""

import json
from json import JSONDecodeError, JSONDecoder
from typing import Any

import partial_json_parser
from partial_json_parser.core.options import Allow


def find_common_prefix(s1: str, s2: str) -> str:
    """Find the common prefix shared between two strings.

    Compares two strings character by character from the beginning and returns
    the longest common prefix. This is used for extracting information from JSON
    generated by partial_json_parser to ensure proper token streaming without
    premature closure of quotes, brackets, or braces.

    Args:
        s1 (str): First string to compare.
        s2 (str): Second string to compare.

    Returns:
        str: The common prefix substring. Returns an empty string if the
            strings share no common prefix.

    Example:
        >>> find_common_prefix('{"fruit": "ap"}', '{"fruit": "apple"}')
        '{"fruit": "ap'
        >>> find_common_prefix("hello", "world")
        ''
        >>> find_common_prefix("testing", "test")
        'test'

    Note:
        The order of arguments does not matter as the function is symmetric.
    """
    prefix = ""
    min_length = min(len(s1), len(s2))
    for i in range(0, min_length):
        if s1[i] == s2[i]:
            prefix += s1[i]
        else:
            break
    return prefix


def find_common_suffix(s1: str, s2: str) -> str:
    """Find the common suffix shared between two strings.

    Compares two strings character by character from the end and returns
    the longest common suffix, stopping when an alphanumeric character is
    encountered. This behavior ensures that partial words or identifiers
    are not incorrectly matched as suffixes.

    Args:
        s1 (str): First string to compare.
        s2 (str): Second string to compare.

    Returns:
        str: The common suffix substring containing only non-alphanumeric
            characters. Returns an empty string if no valid suffix is found.

    Example:
        >>> find_common_suffix('{"fruit": "ap"}', '{"fruit": "apple"}')
        '"}'
        >>> find_common_suffix("test123", "abc123")
        ''  # Stops at alphanumeric '3'
        >>> find_common_suffix("hello!", "world!")
        '!'

    Note:
        The order of arguments does not matter as the function is symmetric.
        The suffix matching stops at alphanumeric characters to prevent
        matching partial words.
    """
    suffix = ""
    min_length = min(len(s1), len(s2))
    for i in range(1, min_length + 1):
        if s1[-i] == s2[-i] and not s1[-i].isalnum():
            suffix = s1[-i] + suffix
        else:
            break
    return suffix


def extract_intermediate_diff(curr: str, old: str) -> str:
    """Extract the difference between two strings accounting for common prefix and suffix.

    This function is used for streaming partial JSON to extract only the new tokens
    that should be sent to the client. It identifies the common prefix and suffix
    between the current and old strings, then returns only the intermediate
    difference. This is critical for proper streaming of tool arguments without
    duplicating or missing content.

    Args:
        curr (str): The new/current version of the partially-parsed JSON string.
            This must be passed as the first argument.
        old (str): The previous version from earlier generation step.
            This must be passed as the second argument.

    Returns:
        str: The intermediate difference that should be streamed to the client.
            This represents only the new content between the common prefix and
            suffix regions.

    Example:
        >>> extract_intermediate_diff('{"fruit": "apple"}', '{"fruit": "ap"}')
        'ple'
        >>> extract_intermediate_diff('{"a": 123}', '{"a": 1}')
        '23'
        >>> extract_intermediate_diff('hello world', 'hello ')
        'world'

    Warning:
        Argument order is important. The new version must be passed as the first
        argument (curr) and the old version as the second argument (old).
        Reversing the order will produce incorrect results.
    """
    suffix = find_common_suffix(curr, old)

    old = old[::-1].replace(suffix[::-1], "", 1)[::-1]
    prefix = find_common_prefix(curr, old)
    diff = curr
    if len(suffix):
        diff = diff[::-1].replace(suffix[::-1], "", 1)[::-1]

    if len(prefix):
        diff = diff.replace(prefix, "", 1)

    return diff


def find_all_indices(string: str, substring: str) -> list[int]:
    """Find all starting indices of a substring within a string.

    Searches through the string and returns a list of all positions where
    the substring begins. This is useful for locating multiple tool call
    boundaries or markers in model output.

    Args:
        string (str): The string to search within.
        substring (str): The substring to find.

    Returns:
        list[int]: A list of starting indices where the substring appears.
            Returns an empty list if the substring is not found.

    Example:
        >>> find_all_indices("hello hello hello", "hello")
        [0, 6, 12]
        >>> find_all_indices("abcabc", "bc")
        [1, 4]
        >>> find_all_indices("test", "xyz")
        []
    """
    indices = []
    index = -1
    while True:
        index = string.find(substring, index + 1)
        if index == -1:
            break
        indices.append(index)
    return indices


def partial_json_loads(input_str: str, flags: Allow) -> tuple[Any, int]:
    """Load and parse potentially incomplete JSON with fallback handling.

    Attempts to parse a JSON string that may be incomplete using the
    partial_json_parser library. If the parser encounters an "Extra data"
    error (indicating multiple JSON objects), it falls back to the standard
    JSON decoder which can handle this case by returning only the first
    complete object.

    Args:
        input_str (str): The JSON string to parse. May be incomplete or
            contain multiple JSON objects.
        flags (Allow): Parsing flags from partial_json_parser.core.options.Allow
            that specify what incomplete structures are allowed (e.g., Allow.ALL,
            Allow.STR, Allow.OBJ).

    Returns:
        tuple[Any, int]: A tuple containing:
            - The parsed Python object (dict, list, str, int, etc.)
            - The number of characters consumed from the input string

    Raises:
        JSONDecodeError: If the JSON is malformed in a way that cannot be
            handled by either parser (not just incomplete).

    Example:
        >>> from partial_json_parser.core.options import Allow
        >>> obj, consumed = partial_json_loads('{"name": "test"', Allow.ALL)
        >>> print(obj)
        {'name': 'test'}
        >>> obj, consumed = partial_json_loads('{"a": 1}{"b": 2}', Allow.ALL)
        >>> print(obj, consumed)
        {'a': 1} 8
    """
    try:
        return (partial_json_parser.loads(input_str, flags), len(input_str))
    except JSONDecodeError as e:
        if "Extra data" in e.msg:
            dec = JSONDecoder()
            return dec.raw_decode(input_str)
        raise


def is_complete_json(input_str: str) -> bool:
    """Check if a string contains complete, valid JSON.

    Attempts to parse the input string as JSON to determine if it represents
    a complete and valid JSON structure. This is used to determine when
    streaming tool call extraction can finalize a tool call.

    Args:
        input_str (str): The string to validate as JSON.

    Returns:
        bool: True if the string is complete, valid JSON that can be parsed
            without error. False if the string is incomplete, malformed,
            or not valid JSON.

    Example:
        >>> is_complete_json('{"name": "test"}')
        True
        >>> is_complete_json('{"name": "test"')
        False
        >>> is_complete_json('not json')
        False
        >>> is_complete_json('[1, 2, 3]')
        True
    """
    try:
        json.loads(input_str)
        return True
    except JSONDecodeError:
        return False


def consume_space(i: int, s: str) -> int:
    """Skip whitespace characters starting from a given index.

    Advances through a string from the given starting index, skipping all
    whitespace characters (spaces, tabs, newlines, etc.) until a
    non-whitespace character is found or the end of the string is reached.

    Args:
        i (int): The starting index in the string.
        s (str): The string to process.

    Returns:
        int: The index of the first non-whitespace character at or after
            position i, or len(s) if the remainder of the string is all
            whitespace.

    Example:
        >>> consume_space(0, "   hello")
        3
        >>> consume_space(5, "hello   world")
        8
        >>> consume_space(0, "hello")
        0
        >>> consume_space(0, "   ")
        3
    """
    while i < len(s) and s[i].isspace():
        i += 1
    return i
